from __future__ import annotations
import unittest
from datetime import date, timedelta
import random

from src.data_structures import LinkedList
from src.core_type import AdvancedTransaction, BasicTransaction # Import BasicTransaction
from src.utils.financial_calculator import InterestType, PenaltyType, FinancialCalculator
from src.algorithms.advanced_transactions.min_cost_max_flow import AdvancedMinCostMaxFlowSimplifier
from src.utils.constants import EPSILON


class TestAdvancedMinCostMaxFlowSimplifier(unittest.TestCase):
    """B·ªô test cho l·ªõp AdvancedMinCostMaxFlowSimplifier"""

    def setUp(self):
        """Kh·ªüi t·∫°o d·ªØ li·ªáu test cho m·ªói tr∆∞·ªùng h·ª£p ki·ªÉm th·ª≠"""
        self.base_date = date(2024, 1, 1)
        self.current_date = date(2024, 6, 1)  # 5 th√°ng sau (152 ng√†y n·∫øu 2024 l√† nƒÉm nhu·∫≠n cho th√°ng 2)
        self.calculator = FinancialCalculator()

    # Helper function ƒë·ªÉ t·∫°o AdvancedTransaction
    def create_adv_tx(self, debtor: str, creditor: str, amount: float,
                      borrow_date: date, due_date: date,
                      interest_rate: float = 0.0, penalty_rate: float = 0.0,
                      interest_type: InterestType = InterestType.SIMPLE,
                      penalty_type: PenaltyType = PenaltyType.FIXED) -> AdvancedTransaction:
        return AdvancedTransaction(debtor, creditor, amount, borrow_date, due_date,
                                   interest_rate, penalty_rate, interest_type, penalty_type)
    
    def test_initialization(self):
        """Ki·ªÉm th·ª≠ vi·ªác kh·ªüi t·∫°o AdvancedMinCostMaxFlowSimplifier"""
        print("\n" + "="*60)
        print("KI·ªÇM TH·ª¨: Kh·ªüi t·∫°o")
        print("="*60)
        transactions = LinkedList[AdvancedTransaction]()
        transactions.append(self.create_adv_tx("Alice", "Bob", 100, self.base_date, self.current_date + timedelta(days=30)))
        transactions.append(self.create_adv_tx("Bob", "Charlie", 80, self.base_date, self.current_date + timedelta(days=30)))
        simplifier = AdvancedMinCostMaxFlowSimplifier(transactions, self.current_date)
        self.assertIsNotNone(simplifier.people_balances)
        # ... (c√°c assert kh√°c c·ªßa b·∫°n) ...
        print("‚úÖ Ki·ªÉm th·ª≠ kh·ªüi t·∫°o ƒë√£ th√†nh c√¥ng")

    def test_simple_debt_no_cycle_no_interest_penalty(self): # ƒê·ªïi t√™n cho r√µ
        """Ki·ªÉm th·ª≠ ƒë∆°n gi·∫£n h√≥a n·ª£ ƒë∆°n gi·∫£n, kh√¥ng chu tr√¨nh, kh√¥ng l√£i/ph·∫°t"""
        print("\n" + "="*60)
        print("KI·ªÇM TH·ª¨: ƒê∆°n gi·∫£n h√≥a, kh√¥ng chu tr√¨nh, kh√¥ng l√£i/ph·∫°t")
        print("="*60)
        transactions = LinkedList[AdvancedTransaction]()
        tx1 = self.create_adv_tx("Alice", "Bob", 100, self.base_date, self.current_date + timedelta(days=30))
        transactions.append(tx1)
        tx2 = self.create_adv_tx("Bob", "Charlie", 80, self.base_date, self.current_date + timedelta(days=30))
        transactions.append(tx2)
        simplifier = AdvancedMinCostMaxFlowSimplifier(transactions, self.current_date)
        simplified = simplifier.simplify() # K·∫øt qu·∫£ l√† LinkedList[BasicTransaction]

        original_count = 2
        simplified_count = len(simplified)
        print(f"üìä S·ªë giao d·ªãch ban ƒë·∫ßu: {original_count}")
        print(f"üìä S·ªë giao d·ªãch sau khi ƒë∆°n gi·∫£n h√≥a: {simplified_count}")
        
        # K·ª≥ v·ªçng: Alice -> Bob: 100, Bob -> Charlie: 80 (v√¨ kh√¥ng c√≥ c√°ch n√†o g·ªôp)
        # Ho·∫∑c Alice -> Charlie: 80, Alice -> Bob: 20 (n·∫øu thu·∫≠t to√°n t·ªëi ∆∞u theo d√≤ng ti·ªÅn t·ªïng th·ªÉ)
        # MinCostMaxFlow n√™n t√¨m ra c√°ch t·ªëi ∆∞u h∆°n l√† gi·ªØ nguy√™n
        # Net balances: Alice: -100, Bob: +100 - 80 = +20, Charlie: +80
        # Expected: Alice -> Charlie: 80, Alice -> Bob: 20
        self.assertEqual(simplified_count, 2, "K·ª≥ v·ªçng 2 giao d·ªãch ƒë∆∞·ª£c t·ªëi ∆∞u")
        
        results_map = {}
        current = simplified.head
        tx_num = 1
        while current:
            tx = current.data
            print(f"üí∏ Giao d·ªãch {tx_num}: {tx.debtor} ‚Üí {tx.creditor} = ${tx.amount:.2f}")
            results_map[f"{tx.debtor}->{tx.creditor}"] = tx.amount
            tx_num += 1
            current = current.next
        
        self.assertAlmostEqual(results_map.get("Alice->Charlie", 0.0), 80.0, delta=EPSILON)
        self.assertAlmostEqual(results_map.get("Alice->Bob", 0.0), 20.0, delta=EPSILON)
        print("‚úÖ Ki·ªÉm th·ª≠ ƒë∆°n gi·∫£n h√≥a, kh√¥ng chu tr√¨nh, kh√¥ng l√£i/ph·∫°t th√†nh c√¥ng")

    def test_circular_debt_no_interest_penalty(self): # ƒê·ªïi t√™n cho r√µ
        """Ki·ªÉm th·ª≠ gi·∫£i quy·∫øt n·ª£ c√≥ chu tr√¨nh, kh√¥ng l√£i/ph·∫°t"""
        print("\n" + "="*60)
        print("KI·ªÇM TH·ª¨: Gi·∫£i quy·∫øt n·ª£ chu tr√¨nh, kh√¥ng l√£i/ph·∫°t")
        print("="*60)
        transactions = LinkedList[AdvancedTransaction]()
        # A -> B: 300
        # B -> C: 250
        # C -> A: 200
        # Min cycle amount = 200.
        # After cycle: A->B: 100, B->C: 50. C->A: 0.
        # Expected: A->B: 100, B->C: 50 (2 transactions)
        # Ho·∫∑c A->C: 50, A->B: 50 (n·∫øu t·ªëi ∆∞u h∆°n)
        # Net balances: A: -300+200 = -100, B: +300-250 = +50, C: +250-200 = +50
        # Expected (optimal): A->B: 50, A->C: 50
        transactions.append(self.create_adv_tx("Alice", "Bob", 300, self.base_date, self.current_date + timedelta(days=30)))
        transactions.append(self.create_adv_tx("Bob", "Charlie", 250, self.base_date, self.current_date + timedelta(days=30)))
        transactions.append(self.create_adv_tx("Charlie", "Alice", 200, self.base_date, self.current_date + timedelta(days=30)))
        simplifier = AdvancedMinCostMaxFlowSimplifier(transactions, self.current_date)
        simplified = simplifier.simplify()

        simplified_count = len(simplified)
        print(f"üìä S·ªë giao d·ªãch chu tr√¨nh ban ƒë·∫ßu: 3")
        print(f"üìä S·ªë giao d·ªãch sau khi ƒë∆°n gi·∫£n h√≥a: {simplified_count}")
        self.assertEqual(simplified_count, 2, "K·ª≥ v·ªçng 2 giao d·ªãch sau khi gi·∫£i quy·∫øt chu tr√¨nh")

        results_map = {}
        current = simplified.head; tx_num=1
        while current:
            tx = current.data
            print(f"üí∏ Giao d·ªãch {tx_num}: {tx.debtor} ‚Üí {tx.creditor} = ${tx.amount:.2f}")
            results_map[f"{tx.debtor}->{tx.creditor}"] = tx.amount
            tx_num+=1; current = current.next
        
        self.assertAlmostEqual(results_map.get("Alice->Bob", 0.0), 50.0, delta=EPSILON)
        self.assertAlmostEqual(results_map.get("Alice->Charlie", 0.0), 50.0, delta=EPSILON)
        print("‚úÖ Ki·ªÉm th·ª≠ gi·∫£i quy·∫øt n·ª£ chu tr√¨nh, kh√¥ng l√£i/ph·∫°t th√†nh c√¥ng")

    def test_empty_transactions_list(self): # ƒê·ªïi t√™n cho nh·∫•t qu√°n
        """Ki·ªÉm th·ª≠ v·ªõi danh s√°ch giao d·ªãch r·ªóng"""
        print("\n" + "="*60)
        print("KI·ªÇM TH·ª¨: Danh s√°ch giao d·ªãch r·ªóng")
        print("="*60)
        empty_transactions = LinkedList[AdvancedTransaction]()
        simplifier = AdvancedMinCostMaxFlowSimplifier(empty_transactions, self.current_date)
        simplified = simplifier.simplify()
        self.assertTrue(simplified.is_empty())
        print("üìä ƒê√£ x·ª≠ l√Ω ch√≠nh x√°c danh s√°ch giao d·ªãch r·ªóng")
        print("‚úÖ Ki·ªÉm th·ª≠ danh s√°ch giao d·ªãch r·ªóng th√†nh c√¥ng")


    def test_single_transaction_with_interest_and_penalty(self):
        """Ki·ªÉm th·ª≠ m·ªôt giao d·ªãch ƒë∆°n l·∫ª c√≥ l√£i v√† ph·∫°t."""
        print("\n" + "="*60)
        print("KI·ªÇM TH·ª¨ M·ªöI: Giao d·ªãch ƒë∆°n l·∫ª v·ªõi l√£i v√† ph·∫°t")
        print("="*60)
        
        due_date_tx = date(2024, 3, 1) 
        tx_params_for_creation = { # Params ƒë·ªÉ t·∫°o AdvancedTransaction
            "debtor": "David", "creditor": "Eve", "amount": 1000.0,
            "borrow_date": self.base_date, "due_date": due_date_tx,
            "interest_rate": 0.12, "penalty_rate": 50.0, 
            "interest_type": InterestType.COMPOUND_MONTHLY, "penalty_type": PenaltyType.FIXED
        }
        transactions = LinkedList[AdvancedTransaction]()
        transactions.append(self.create_adv_tx(**tx_params_for_creation))

        # T·∫†O DICTIONARY CH·ªà CH·ª®A C√ÅC THAM S·ªê CHO calculate_total_debt
        params_for_calculator = {
            "amount": tx_params_for_creation["amount"],
            "interest_rate": tx_params_for_creation["interest_rate"],
            "penalty_rate": tx_params_for_creation["penalty_rate"],
            "borrow_date": tx_params_for_creation["borrow_date"],
            "due_date": tx_params_for_creation["due_date"],
            "interest_type": tx_params_for_creation["interest_type"],
            "penalty_type": tx_params_for_creation["penalty_type"]
            # current_date s·∫Ω ƒë∆∞·ª£c truy·ªÅn ri√™ng
        }

        expected_breakdown = self.calculator.calculate_total_debt(
            **params_for_calculator, # Unpack dictionary ƒë√£ ƒë∆∞·ª£c l·ªçc
            current_date=self.current_date
        )
        expected_total_debt = expected_breakdown["total"]
        print(f"  T√≠nh to√°n k·ª≥ v·ªçng: G·ªëc={expected_breakdown['principal']:.2f}, L√£i={expected_breakdown['interest']:.2f}, Ph·∫°t={expected_breakdown['penalty']:.2f}, T·ªïng={expected_total_debt:.2f}")

        simplifier = AdvancedMinCostMaxFlowSimplifier(transactions, self.current_date)
        simplified = simplifier.simplify()

        self.assertEqual(len(simplified), 1, "K·ª≥ v·ªçng 1 giao d·ªãch")
        result_tx = simplified.head.data
        print(f"üí∏ Giao d·ªãch ƒë∆°n gi·∫£n h√≥a: {result_tx.debtor} ‚Üí {result_tx.creditor} = ${result_tx.amount:.2f}")

        self.assertEqual(result_tx.debtor, "David")
        self.assertEqual(result_tx.creditor, "Eve")
        self.assertAlmostEqual(result_tx.amount, expected_total_debt, delta=0.01)
        print("‚úÖ Ki·ªÉm th·ª≠ giao d·ªãch ƒë∆°n l·∫ª v·ªõi l√£i/ph·∫°t th√†nh c√¥ng")

    def test_two_transactions_cancel_out_with_finance(self):
        """Ki·ªÉm th·ª≠ hai giao d·ªãch ng∆∞·ª£c chi·ªÅu c√≥ th·ªÉ tri·ªát ti√™u m·ªôt ph·∫ßn sau khi t√≠nh l√£i/ph·∫°t."""
        print("\n" + "="*60)
        print("KI·ªÇM TH·ª¨ M·ªöI: Hai giao d·ªãch ng∆∞·ª£c chi·ªÅu, tri·ªát ti√™u m·ªôt ph·∫ßn v·ªõi l√£i/ph·∫°t")
        print("="*60)

        transactions = LinkedList[AdvancedTransaction]()
        
        tx1_params_for_creation = {
            "debtor": "Frank", "creditor": "Grace", "amount": 500.0,
            "borrow_date": self.base_date, "due_date": date(2024, 4, 1), 
            "interest_rate": 0.10, "penalty_rate": 0.05, 
            "interest_type": InterestType.SIMPLE, "penalty_type": PenaltyType.PERCENTAGE
        }
        transactions.append(self.create_adv_tx(**tx1_params_for_creation))
        
        tx2_params_for_creation = {
            "debtor": "Grace", "creditor": "Frank", "amount": 300.0,
            "borrow_date": date(2024, 2, 1), "due_date": date(2024, 5, 1), 
            "interest_rate": 0.08, "penalty_rate": 20.0, 
            "interest_type": InterestType.COMPOUND_DAILY, "penalty_type": PenaltyType.FIXED
        }
        transactions.append(self.create_adv_tx(**tx2_params_for_creation))

        # Helper function ƒë·ªÉ tr√≠ch xu·∫•t params cho calculator (c√≥ th·ªÉ ƒë·ªÉ ·ªü setUp ho·∫∑c ngo√†i class)
        def get_calc_params_from_creation_dict(details_dict):
            return {
                "amount": details_dict["amount"],
                "interest_rate": details_dict["interest_rate"],
                "penalty_rate": details_dict["penalty_rate"],
                "borrow_date": details_dict["borrow_date"],
                "due_date": details_dict["due_date"],
                "interest_type": details_dict["interest_type"],
                "penalty_type": details_dict["penalty_type"]
            }

        val_tx1 = self.calculator.calculate_total_debt(
            **get_calc_params_from_creation_dict(tx1_params_for_creation), # S·ª≠ d·ª•ng dict ƒë√£ l·ªçc
            current_date=self.current_date
        )["total"]
        val_tx2 = self.calculator.calculate_total_debt(
            **get_calc_params_from_creation_dict(tx2_params_for_creation), # S·ª≠ d·ª•ng dict ƒë√£ l·ªçc
            current_date=self.current_date
        )["total"]
        
        print(f"  Gi√° tr·ªã th·ª±c t·∫ø TX1 (Frank->Grace): ${val_tx1:.2f}")
        print(f"  Gi√° tr·ªã th·ª±c t·∫ø TX2 (Grace->Frank): ${val_tx2:.2f}")
        
        # ... (ph·∫ßn c√≤n l·∫°i c·ªßa logic assert d·ª±a tr√™n val_tx1 v√† val_tx2) ...
        simplifier = AdvancedMinCostMaxFlowSimplifier(transactions, self.current_date)
        simplified = simplifier.simplify()

        if val_tx1 > val_tx2 + EPSILON:
            expected_debtor = "Frank"
            expected_creditor = "Grace"
            expected_amount = val_tx1 - val_tx2
            self.assertEqual(len(simplified), 1, "K·ª≥ v·ªçng 1 giao d·ªãch sau khi b√π tr·ª´")
            if not simplified.is_empty():
                result_tx = simplified.head.data
                print(f"üí∏ Giao d·ªãch ƒë∆°n gi·∫£n h√≥a: {result_tx.debtor} ‚Üí {result_tx.creditor} = ${result_tx.amount:.2f}")
                self.assertEqual(result_tx.debtor, expected_debtor)
                self.assertEqual(result_tx.creditor, expected_creditor)
                self.assertAlmostEqual(result_tx.amount, expected_amount, delta=0.01)
        elif val_tx2 > val_tx1 + EPSILON:
            expected_debtor = "Grace"
            expected_creditor = "Frank"
            expected_amount = val_tx2 - val_tx1
            self.assertEqual(len(simplified), 1, "K·ª≥ v·ªçng 1 giao d·ªãch sau khi b√π tr·ª´")
            if not simplified.is_empty():
                result_tx = simplified.head.data
                print(f"üí∏ Giao d·ªãch ƒë∆°n gi·∫£n h√≥a: {result_tx.debtor} ‚Üí {result_tx.creditor} = ${result_tx.amount:.2f}")
                self.assertEqual(result_tx.debtor, expected_debtor)
                self.assertEqual(result_tx.creditor, expected_creditor)
                self.assertAlmostEqual(result_tx.amount, expected_amount, delta=0.01)
        else: 
            print(f"üí∏ Giao d·ªãch g·∫ßn nh∆∞ tri·ªát ti√™u ho√†n to√†n.")
            self.assertTrue(simplified.is_empty() or simplified.head.data.amount < EPSILON * 100, 
                            "K·ª≥ v·ªçng kh√¥ng c√≥ giao d·ªãch ho·∫∑c giao d·ªãch v·ªõi s·ªë ti·ªÅn r·∫•t nh·ªè")

        print("‚úÖ Ki·ªÉm th·ª≠ hai giao d·ªãch ng∆∞·ª£c chi·ªÅu v·ªõi l√£i/ph·∫°t th√†nh c√¥ng")

    def test_complex_scenario_three_people_interest_penalty(self):
        """Ki·ªÉm th·ª≠ k·ªãch b·∫£n 3 ng∆∞·ªùi ƒë√£ debug v·ªõi AdvancedDebtCycleSimplifier."""
        print("\n" + "="*60)
        print("KI·ªÇM TH·ª¨ M·ªöI: K·ªãch b·∫£n 3 ng∆∞·ªùi (Anna, Bob, Cathy) v·ªõi l√£i/ph·∫°t")
        print("="*60)
        
        transactions = LinkedList[AdvancedTransaction]()
        tx1_details = {"debtor": "Anna", "creditor": "Bob", "amount": 100.00,
                       "borrow_date": self.base_date, "due_date": date(2024, 3, 1),
                       "interest_rate": 0.08, "penalty_rate": 15.00,
                       "interest_type": InterestType.COMPOUND_MONTHLY, "penalty_type": PenaltyType.FIXED}
        transactions.append(self.create_adv_tx(**tx1_details))

        tx2_details = {"debtor": "Bob", "creditor": "Cathy", "amount": 150.00,
                       "borrow_date": self.base_date, "due_date": date(2024, 4, 15),
                       "interest_rate": 0.05, "penalty_rate": 0.10, 
                       "interest_type": InterestType.SIMPLE, "penalty_type": PenaltyType.PERCENTAGE}
        transactions.append(self.create_adv_tx(**tx2_details))
        
        tx3_details = {"debtor": "Cathy", "creditor": "Anna", "amount": 90.00,
                       "borrow_date": self.base_date, "due_date": date(2024, 2, 10),
                       "interest_rate": 0.001, "penalty_rate": 20.00, 
                       "interest_type": InterestType.COMPOUND_DAILY, "penalty_type": PenaltyType.FIXED}
        transactions.append(self.create_adv_tx(**tx3_details))

        # T√≠nh to√°n s·ªë d∆∞ r√≤ng k·ª≥ v·ªçng (t·ª´ c√°c l·∫ßn debug tr∆∞·ªõc)
        # Anna n·ª£ r√≤ng ~8.32-8.34
        # Bob n·ª£ r√≤ng ~49.75-49.76
        # Cathy ƒë∆∞·ª£c nh·∫≠n r√≤ng ~58.08-58.09
        # K·ª≥ v·ªçng: Anna -> Cathy: ~8.34, Bob -> Cathy: ~49.75

        simplifier = AdvancedMinCostMaxFlowSimplifier(transactions, self.current_date)
        simplified = simplifier.simplify()

        self.assertEqual(len(simplified), 2, "K·ª≥ v·ªçng 2 giao d·ªãch sau khi ƒë∆°n gi·∫£n h√≥a k·ªãch b·∫£n 3 ng∆∞·ªùi")

        print("üí∏ C√°c giao d·ªãch ƒë√£ ƒë∆∞·ª£c ƒë∆°n gi·∫£n h√≥a:")
        results_map = {}
        current = simplified.head; tx_num=1
        while current:
            tx = current.data
            print(f"  Giao d·ªãch {tx_num}: {tx.debtor} ‚Üí {tx.creditor} = ${tx.amount:.2f}")
            results_map[f"{tx.debtor}->{tx.creditor}"] = tx.amount
            tx_num+=1; current = current.next
            
        self.assertAlmostEqual(results_map.get("Anna->Cathy", 0.0), 8.34, delta=0.03)
        self.assertAlmostEqual(results_map.get("Bob->Cathy", 0.0), 49.75, delta=0.03)
        
        print("‚úÖ Ki·ªÉm th·ª≠ k·ªãch b·∫£n 3 ng∆∞·ªùi v·ªõi l√£i/ph·∫°t th√†nh c√¥ng")

    def test_no_net_change_multiple_parties(self):
        """Ki·ªÉm th·ª≠ tr∆∞·ªùng h·ª£p nhi·ªÅu b√™n nh∆∞ng t·ªïng n·ª£ r√≤ng b·∫±ng 0 cho m·ªói ng∆∞·ªùi."""
        print("\n" + "="*60)
        print("KI·ªÇM TH·ª¨ M·ªöI: Kh√¥ng thay ƒë·ªïi r√≤ng, nhi·ªÅu b√™n")
        print("="*60)
        transactions = LinkedList[AdvancedTransaction]()
        # A -> B: 100
        # B -> C: 100
        # C -> A: 100
        # (Kh√¥ng l√£i/ph·∫°t, due date trong t∆∞∆°ng lai ƒë·ªÉ tr√°nh ph·∫°t)
        future_due = self.current_date + timedelta(days=30)
        transactions.append(self.create_adv_tx("A", "B", 100, self.base_date, future_due))
        transactions.append(self.create_adv_tx("B", "C", 100, self.base_date, future_due))
        transactions.append(self.create_adv_tx("C", "A", 100, self.base_date, future_due))
        # Th√™m m·ªôt c·∫∑p kh√°c c≈©ng t·ª± tri·ªát ti√™u
        # D -> E: 50
        # E -> D: 50
        transactions.append(self.create_adv_tx("D", "E", 50, self.base_date, future_due))
        transactions.append(self.create_adv_tx("E", "D", 50, self.base_date, future_due))


        simplifier = AdvancedMinCostMaxFlowSimplifier(transactions, self.current_date)
        simplified = simplifier.simplify()

        print("üí∏ C√°c giao d·ªãch ƒë√£ ƒë∆∞·ª£c ƒë∆°n gi·∫£n h√≥a (k·ª≥ v·ªçng r·ªóng):")
        is_empty = True
        current = simplified.head
        while current:
            tx = current.data
            print(f"  L·ªói: {tx.debtor} ‚Üí {tx.creditor} = ${tx.amount:.2f}")
            is_empty = False
            current = current.next

        self.assertTrue(is_empty, "K·ª≥ v·ªçng kh√¥ng c√≥ giao d·ªãch n√†o sau khi ƒë∆°n gi·∫£n h√≥a")
        print("‚úÖ Ki·ªÉm th·ª≠ kh√¥ng thay ƒë·ªïi r√≤ng, nhi·ªÅu b√™n th√†nh c√¥ng")


if __name__ == '__main__':
    unittest.main(verbosity=2)