from __future__ import annotations
import unittest

from src.data_structures import LinkedList
from src.core_type import BasicTransaction
from src.algorithms.basic_transactions.dynamic_programming import DynamicProgrammingSimplifier
from src.utils.constants import EPSILON
from src.utils.money_utils import round_money

class TestDynamicProgrammingSimplifier(unittest.TestCase):
    """B·ªô ki·ªÉm th·ª≠ cho DynamicProgrammingSimplifier."""

    def assertTransactionsMatch(self, actual_tx_list: LinkedList[BasicTransaction], 
                                expected_txs: list[tuple[str, str, float]]):
        """
        H√†m tr·ª£ gi√∫p ƒë·ªÉ so s√°nh danh s√°ch giao d·ªãch th·ª±c t·∫ø v·ªõi danh s√°ch k·ª≥ v·ªçng.
        Ki·ªÉm tra s·ªë l∆∞·ª£ng giao d·ªãch v√† n·ªôi dung c·ªßa ch√∫ng.
        S·ª≠ d·ª•ng m·ªôt map ƒë·ªÉ kh√¥ng ph·ª• thu·ªôc v√†o th·ª© t·ª± c·ªßa c√°c giao d·ªãch ƒë∆∞·ª£c tr·∫£ v·ªÅ.
        """
        self.assertEqual(len(actual_tx_list), len(expected_txs), 
                         f"S·ªë l∆∞·ª£ng giao d·ªãch kh√¥ng kh·ªõp. K·ª≥ v·ªçng: {len(expected_txs)}, Th·ª±c t·∫ø: {len(actual_tx_list)}")

        # Chuy·ªÉn ƒë·ªïi expected_txs th√†nh m·ªôt d·∫°ng d·ªÖ so s√°nh h∆°n (map)
        expected_map = {}
        for d, c, amt in expected_txs:
            # L√†m tr√≤n s·ªë ti·ªÅn k·ª≥ v·ªçng ƒë·ªÉ so s√°nh nh·∫•t qu√°n
            expected_map[tuple(sorted((d, c)))] = round_money(amt)

        actual_map = {}
        current = actual_tx_list.head
        while current:
            tx = current.data
            # L√†m tr√≤n s·ªë ti·ªÅn th·ª±c t·∫ø
            actual_map[tuple(sorted((tx.debtor, tx.creditor)))] = round_money(tx.amount)
            current = current.next
        
        for key_pair, expected_amt in expected_map.items():
            actual_amt = actual_map.get(key_pair)
            self.assertIsNotNone(actual_amt, f"Thi·∫øu giao d·ªãch k·ª≥ v·ªçng gi·ªØa {key_pair[0]} v√† {key_pair[1]}")
            self.assertAlmostEqual(actual_amt, expected_amt, delta=EPSILON,
                                   msg=f"S·ªë ti·ªÅn giao d·ªãch gi·ªØa {key_pair[0]} v√† {key_pair[1]} kh√¥ng kh·ªõp. K·ª≥ v·ªçng: {expected_amt}, Th·ª±c t·∫ø: {actual_amt}")

    def test_empty_transactions_dp(self):
        print("\n" + "=" * 60)
        print("DP KI·ªÇM TH·ª¨: Danh s√°ch giao d·ªãch r·ªóng")
        print("=" * 60)
        transactions = LinkedList[BasicTransaction]()
        simplifier = DynamicProgrammingSimplifier(transactions)
        simplified = simplifier.simplify()
        self.assertTrue(simplified.is_empty())
        print("‚úÖ DP Ki·ªÉm th·ª≠ danh s√°ch giao d·ªãch r·ªóng th√†nh c√¥ng")

    def test_single_transaction_dp(self):
        print("\n" + "=" * 60)
        print("DP KI·ªÇM TH·ª¨: Giao d·ªãch ƒë∆°n l·∫ª")
        print("=" * 60)
        transactions = LinkedList[BasicTransaction]()
        transactions.append(BasicTransaction("Alice", "Bob", 100.0))
        simplifier = DynamicProgrammingSimplifier(transactions)
        simplified = simplifier.simplify()
        
        expected = [("Alice", "Bob", 100.0)]
        self.assertTransactionsMatch(simplified, expected)
        print(f"üí∏ K·∫øt qu·∫£: {simplified.head.data.debtor} ‚Üí {simplified.head.data.creditor} = ${simplified.head.data.amount:.2f}")
        print("‚úÖ DP Ki·ªÉm th·ª≠ giao d·ªãch ƒë∆°n l·∫ª th√†nh c√¥ng")

    def test_direct_cancellation_dp(self):
        print("\n" + "=" * 60)
        print("DP KI·ªÇM TH·ª¨: B√π tr·ª´ tr·ª±c ti·∫øp (A->B, B->A)")
        print("=" * 60)
        transactions = LinkedList[BasicTransaction]()
        transactions.append(BasicTransaction("Alice", "Bob", 100.0))
        transactions.append(BasicTransaction("Bob", "Alice", 70.0))
        simplifier = DynamicProgrammingSimplifier(transactions)
        simplified = simplifier.simplify()

        expected = [("Alice", "Bob", 30.0)]
        self.assertTransactionsMatch(simplified, expected)
        print(f"üí∏ K·∫øt qu·∫£: {simplified.head.data.debtor} ‚Üí {simplified.head.data.creditor} = ${simplified.head.data.amount:.2f}")
        print("‚úÖ DP Ki·ªÉm th·ª≠ b√π tr·ª´ tr·ª±c ti·∫øp th√†nh c√¥ng")

    def test_three_party_cycle_dp(self):
        print("\n" + "=" * 60)
        print("DP KI·ªÇM TH·ª¨: Chu tr√¨nh 3 b√™n (A->B, B->C, C->A) - Tri·ªát ti√™u ho√†n to√†n")
        print("=" * 60)
        transactions = LinkedList[BasicTransaction]()
        transactions.append(BasicTransaction("A", "B", 50.0))
        transactions.append(BasicTransaction("B", "C", 50.0))
        transactions.append(BasicTransaction("C", "A", 50.0))
        simplifier = DynamicProgrammingSimplifier(transactions)
        simplified = simplifier.simplify()

        self.assertTrue(simplified.is_empty(), "Chu tr√¨nh 3 b√™n b·∫±ng nhau n√™n tri·ªát ti√™u h·∫øt")
        print("üí∏ K·∫øt qu·∫£: Kh√¥ng c√≥ giao d·ªãch (ƒë√£ tri·ªát ti√™u)")
        print("‚úÖ DP Ki·ªÉm th·ª≠ chu tr√¨nh 3 b√™n tri·ªát ti√™u ho√†n to√†n th√†nh c√¥ng")

    def test_three_party_cycle_with_remaining_debt_dp(self):
        print("\n" + "=" * 60)
        print("DP KI·ªÇM TH·ª¨: Chu tr√¨nh 3 b√™n v·ªõi n·ª£ c√≤n l·∫°i")
        print("=" * 60)
        # A -100-> B -70-> C -50-> A
        # Min in cycle = 50 (C->A)
        # Sau khi tr·ª´ 50: A->B: 50, B->C: 20, C->A: 0
        # K·∫øt qu·∫£ c√≤n l·∫°i: A->B: 50, B->C: 20
        # Ho·∫∑c DP c√≥ th·ªÉ t·ªëi ∆∞u h∆°n: A->C: 20, A->B: 30 (v√¨ A n·ª£ t·ªïng 50, B nh·∫≠n 50-20=30, C nh·∫≠n 20)
        # Net balances: A: -100+50 = -50; B: +100-70 = +30; C: +70-50 = +20
        # Expected: A->B: 30, A->C: 20
        transactions = LinkedList[BasicTransaction]()
        transactions.append(BasicTransaction("A", "B", 100.0))
        transactions.append(BasicTransaction("B", "C", 70.0))
        transactions.append(BasicTransaction("C", "A", 50.0))
        simplifier = DynamicProgrammingSimplifier(transactions)
        simplified = simplifier.simplify()

        expected = [("A", "B", 30.0), ("A", "C", 20.0)]
        self.assertTransactionsMatch(simplified, expected)
        print("üí∏ K·∫øt qu·∫£:")
        current = simplified.head
        while current: print(f"  {current.data.debtor} ‚Üí {current.data.creditor} = ${current.data.amount:.2f}"); current = current.next
        print("‚úÖ DP Ki·ªÉm th·ª≠ chu tr√¨nh 3 b√™n v·ªõi n·ª£ c√≤n l·∫°i th√†nh c√¥ng")

    def test_four_party_chain_dp(self):
        print("\n" + "=" * 60)
        print("DP KI·ªÇM TH·ª¨: Chu·ªói 4 b√™n (A->B, B->C, C->D)")
        print("=" * 60)
        # A -100-> B -70-> C -50-> D
        # Net balances: A: -100, B: +100-70=+30, C: +70-50=+20, D: +50
        # DP c√≥ th·ªÉ t√¨m ra: A->D: 50, A->C: 20, A->B: 30 (3 transactions)
        transactions = LinkedList[BasicTransaction]()
        transactions.append(BasicTransaction("A", "B", 100.0))
        transactions.append(BasicTransaction("B", "C", 70.0))
        transactions.append(BasicTransaction("C", "D", 50.0))
        simplifier = DynamicProgrammingSimplifier(transactions)
        simplified = simplifier.simplify()

        expected = [("A", "D", 50.0), ("A", "C", 20.0), ("A", "B", 30.0)]
        self.assertTransactionsMatch(simplified, expected)
        print("üí∏ K·∫øt qu·∫£:")
        current = simplified.head
        while current: print(f"  {current.data.debtor} ‚Üí {current.data.creditor} = ${current.data.amount:.2f}"); current = current.next
        print("‚úÖ DP Ki·ªÉm th·ª≠ chu·ªói 4 b√™n th√†nh c√¥ng")

    def test_four_party_cycle_dp(self):
        print("\n" + "=" * 60)
        print("DP KI·ªÇM TH·ª¨: Chu tr√¨nh 4 b√™n (P->Q, Q->R, R->S, S->P)")
        print("=" * 60)
        # P -40-> Q -35-> R -25-> S -20-> P
        # Min in cycle = 20 (S->P)
        # Net balances:
        # P: -40+20 = -20
        # Q: +40-35 = +5
        # R: +35-25 = +10
        # S: +25-20 = +5
        # Sum of positive = 5+10+5 = 20. Matches sum of negative.
        # Expected: P->R: 10, P->Q: 5, P->S: 5
        transactions = LinkedList[BasicTransaction]()
        transactions.append(BasicTransaction("P", "Q", 40.0))
        transactions.append(BasicTransaction("Q", "R", 35.0))
        transactions.append(BasicTransaction("R", "S", 25.0))
        transactions.append(BasicTransaction("S", "P", 20.0))
        simplifier = DynamicProgrammingSimplifier(transactions)
        simplified = simplifier.simplify()

        expected = [("P", "R", 10.0), ("P", "Q", 5.0), ("P", "S", 5.0)]
        self.assertTransactionsMatch(simplified, expected)
        print("üí∏ K·∫øt qu·∫£:")
        current = simplified.head
        while current: print(f"  {current.data.debtor} ‚Üí {current.data.creditor} = ${current.data.amount:.2f}"); current = current.next
        print("‚úÖ DP Ki·ªÉm th·ª≠ chu tr√¨nh 4 b√™n th√†nh c√¥ng")

    def test_complex_case_multiple_paths_dp(self):
        print("\n" + "=" * 60)
        print("DP KI·ªÇM TH·ª¨: Tr∆∞·ªùng h·ª£p ph·ª©c t·∫°p nhi·ªÅu ƒë∆∞·ªùng n·ª£")
        print("=" * 60)
        # A->B: 10, A->C: 10
        # B->D: 5, C->D: 5
        # Net Balances: A: -20, B: +10-5=+5, C: +10-5=+5, D: +5+5=+10
        # Expected: A->D: 10, A->B: 5, A->C: 5
        transactions = LinkedList[BasicTransaction]()
        transactions.append(BasicTransaction("A", "B", 10.0))
        transactions.append(BasicTransaction("A", "C", 10.0))
        transactions.append(BasicTransaction("B", "D", 5.0))
        transactions.append(BasicTransaction("C", "D", 5.0))
        simplifier = DynamicProgrammingSimplifier(transactions)
        simplified = simplifier.simplify()

        expected = [("A", "D", 10.0), ("A", "B", 5.0), ("A", "C", 5.0)]
        self.assertTransactionsMatch(simplified, expected)
        print("üí∏ K·∫øt qu·∫£:")
        current = simplified.head
        while current: print(f"  {current.data.debtor} ‚Üí {current.data.creditor} = ${current.data.amount:.2f}"); current = current.next
        print("‚úÖ DP Ki·ªÉm th·ª≠ tr∆∞·ªùng h·ª£p ph·ª©c t·∫°p th√†nh c√¥ng")

    def test_one_debtor_multiple_creditors_dp(self):
        print("\n" + "=" * 60)
        print("DP KI·ªÇM TH·ª¨: M·ªôt ng∆∞·ªùi n·ª£ nhi·ªÅu ng∆∞·ªùi")
        print("=" * 60)
        # A -> B: 30
        # A -> C: 40
        # A -> D: 50
        # Net Balances: A: -120, B: +30, C: +40, D: +50
        # Expected: A->B:30, A->C:40, A->D:50 (DP should keep these as optimal if no cycles)
        transactions = LinkedList[BasicTransaction]()
        transactions.append(BasicTransaction("A", "B", 30.0))
        transactions.append(BasicTransaction("A", "C", 40.0))
        transactions.append(BasicTransaction("A", "D", 50.0))
        simplifier = DynamicProgrammingSimplifier(transactions)
        simplified = simplifier.simplify()

        expected = [("A", "B", 30.0), ("A", "C", 40.0), ("A", "D", 50.0)]
        self.assertTransactionsMatch(simplified, expected)
        print("üí∏ K·∫øt qu·∫£:")
        current = simplified.head
        while current: print(f"  {current.data.debtor} ‚Üí {current.data.creditor} = ${current.data.amount:.2f}"); current = current.next
        print("‚úÖ DP Ki·ªÉm th·ª≠ m·ªôt ng∆∞·ªùi n·ª£ nhi·ªÅu ng∆∞·ªùi th√†nh c√¥ng")

    def test_multiple_debtors_one_creditor_dp(self):
        print("\n" + "=" * 60)
        print("DP KI·ªÇM TH·ª¨: Nhi·ªÅu ng∆∞·ªùi n·ª£ m·ªôt ng∆∞·ªùi")
        print("=" * 60)
        # A -> D: 30
        # B -> D: 40
        # C -> D: 50
        # Net Balances: A: -30, B: -40, C: -50, D: +120
        # Expected: A->D:30, B->D:40, C->D:50
        transactions = LinkedList[BasicTransaction]()
        transactions.append(BasicTransaction("A", "D", 30.0))
        transactions.append(BasicTransaction("B", "D", 40.0))
        transactions.append(BasicTransaction("C", "D", 50.0))
        simplifier = DynamicProgrammingSimplifier(transactions)
        simplified = simplifier.simplify()

        expected = [("A", "D", 30.0), ("B", "D", 40.0), ("C", "D", 50.0)]
        self.assertTransactionsMatch(simplified, expected)
        print("üí∏ K·∫øt qu·∫£:")
        current = simplified.head
        while current: print(f"  {current.data.debtor} ‚Üí {current.data.creditor} = ${current.data.amount:.2f}"); current = current.next
        print("‚úÖ DP Ki·ªÉm th·ª≠ nhi·ªÅu ng∆∞·ªùi n·ª£ m·ªôt ng∆∞·ªùi th√†nh c√¥ng")

    def test_five_party_complex_cycle_and_chain_dp(self):
        print("\n" + "=" * 60)
        print("DP KI·ªÇM TH·ª¨: 5 b√™n, chu tr√¨nh v√† chu·ªói ph·ª©c t·∫°p")
        print("=" * 60)
        # A->B: 100
        # B->C: 80
        # C->A: 60 (Cycle A-B-C, min 60. A->B: 40, B->C: 20)
        # C->D: 70 (Sau cycle, C c√≤n n·ª£ D: 70)
        # D->E: 50
        #
        # Sau cycle A-B-C:
        # A->B: 40
        # B->C: 20
        # C->D: 70
        # D->E: 50
        #
        # Net Balances:
        # A: -40
        # B: +40-20 = +20
        # C: +20-70 = -50
        # D: +70-50 = +20
        # E: +50
        # Sum Neg: -40-50 = -90. Sum Pos: +20+20+50 = +90. OK.
        #
        # Expected (m·ªôt kh·∫£ nƒÉng t·ªëi ∆∞u t·ª´ DP):
        # A->B: 20 (B c·∫ßn 20)
        # A->D: 20 (D c·∫ßn 20, A c√≤n n·ª£ 20)
        # C->E: 50 (C n·ª£ 50, E c·∫ßn 50)
        transactions = LinkedList[BasicTransaction]()
        transactions.append(BasicTransaction("A", "B", 100.0))
        transactions.append(BasicTransaction("B", "C", 80.0))
        transactions.append(BasicTransaction("C", "A", 60.0))
        transactions.append(BasicTransaction("C", "D", 70.0))
        transactions.append(BasicTransaction("D", "E", 50.0))
        simplifier = DynamicProgrammingSimplifier(transactions)
        simplified = simplifier.simplify()

        expected = [("A", "B", 20.0), ("A", "D", 20.0), ("C", "E", 50.0)]
        self.assertTransactionsMatch(simplified, expected)
        print("üí∏ K·∫øt qu·∫£:")
        current = simplified.head
        while current: print(f"  {current.data.debtor} ‚Üí {current.data.creditor} = ${current.data.amount:.2f}"); current = current.next
        print("‚úÖ DP Ki·ªÉm th·ª≠ 5 b√™n ph·ª©c t·∫°p th√†nh c√¥ng")

if __name__ == '__main__':
    unittest.main(verbosity=2)